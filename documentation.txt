================================================================================
                    WISATA AI BALIKPAPAN - PROJECT DOCUMENTATION
                         A* Algorithm Tourism Route Planner
================================================================================

TABLE OF CONTENTS
-----------------
1. Project Overview
2. System Architecture
3. File Structure
4. Core Components
5. Algorithm Implementation
6. API Endpoints
7. Frontend Implementation
8. Data Flow
9. Setup & Installation
10. Usage Guide
11. Technical Details
12. Future Improvements

================================================================================
1. PROJECT OVERVIEW
================================================================================

Project Name: Wisata AI Balikpapan (A* Tourism Route Planner)
Purpose: An intelligent tourism route planning application for Balikpapan city
         using custom A* pathfinding algorithm and TSP (Traveling Salesman 
         Problem) optimization.

Key Features:
- Custom A* pathfinding implementation (no external pathfinding libraries)
- Multi-destination route optimization
- Interactive web-based map interface
- Real-time route visualization
- Point of Interest (POI) clustering
- Responsive UI with search functionality

Technology Stack:
- Backend: Python, Flask
- Frontend: HTML, CSS, JavaScript, Leaflet.js
- Data Processing: OSMnx, GeoPandas
- Map Visualization: OpenStreetMap, Leaflet.js
- UI Components: TomSelect (dropdown), MarkerCluster

================================================================================
2. SYSTEM ARCHITECTURE
================================================================================

The application follows a client-server architecture:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CLIENT SIDE                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  index.htmlâ”‚  â”‚  Leaflet.js  â”‚  â”‚  TomSelect UI    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                    HTTP Requests (JSON)
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        SERVER SIDE                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚   app.py   â”‚  (Flask Routes)                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚        â”‚                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚           a_star/backend.py                         â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚
â”‚  â”‚  â”‚   my_astar   â”‚  â”‚ heuristic_distâ”‚ â”‚solve_tourâ”‚   â”‚    â”‚
â”‚  â”‚  â”‚  (A* Core)   â”‚  â”‚  (Haversine)  â”‚ â”‚  (TSP)   â”‚   â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                    Data Loading
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          DATA                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ balikpapan_jalan     â”‚  â”‚ balikpapan_pois.gpkg     â”‚     â”‚
â”‚  â”‚     .graphml         â”‚  â”‚  (Points of Interest)    â”‚     â”‚
â”‚  â”‚  (Road Network)      â”‚  â”‚                          â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
3. FILE STRUCTURE
================================================================================

TubesProject/
â”œâ”€â”€ app.py                          # Flask application entry point
â”œâ”€â”€ README.md                       # Project overview
â”œâ”€â”€ .gitignore                      # Git ignore configuration
â”‚
â”œâ”€â”€ a_star/                         # Core algorithm module
â”‚   â”œâ”€â”€ __init__.py                # Package initializer
â”‚   â”œâ”€â”€ backend.py                 # Main algorithm implementation
â”‚   â””â”€â”€ __pycache__/               # Python cache
â”‚
â”œâ”€â”€ data/                          # Geographic data (backend)
â”‚   â”œâ”€â”€ balikpapan_jalan.graphml  # Road network graph
â”‚   â””â”€â”€ balikpapan_pois.gpkg      # Points of interest
â”‚
â”œâ”€â”€ data_web/                      # Geographic data (frontend)
â”‚   â”œâ”€â”€ jalan_balikpapan.geojson  # Roads for web display
â”‚   â””â”€â”€ poi_balikpapan.geojson    # POIs for web display
â”‚
â”œâ”€â”€ static/                        # Static assets
â”‚   â””â”€â”€ assets/                    # Marker icons
â”‚       â”œâ”€â”€ marker-icon-grey.png
â”‚       â”œâ”€â”€ marker-icon-green.png
â”‚       â””â”€â”€ marker-icon-red.png
â”‚
â””â”€â”€ templates/                     # HTML templates
    â””â”€â”€ index.html                 # Main web interface

================================================================================
4. CORE COMPONENTS
================================================================================

4.1 APP.PY - Flask Application Controller
------------------------------------------
Location: /app.py

Purpose: Main server application that handles HTTP requests and coordinates
         between frontend and backend logic.

Key Components:

1. Global Variables:
   - G_global: Loaded road network graph (NetworkX MultiDiGraph)
   - pois_global: GeoDataFrame containing all points of interest

2. Routes:
   a) @app.route('/')
      - Serves the main HTML interface
      - Returns: templates/index.html

   b) @app.route('/api/pois')
      - Provides POI data for frontend dropdowns
      - Returns: JSON array of {id, name, lat, lon}
      - Example response:
        [
          {"id": 0, "name": "Alfamidi Ahmad Yani", "lat": -1.248, "lon": 116.86},
          {"id": 1, "name": "Pantai Lamaru", "lat": -1.234, "lon": 116.87}
        ]

   c) @app.route('/api/route', methods=['POST'])
      - Calculates optimal route based on user selection
      - Input: {"start_id": 0, "dest_ids": [1, 5, 10]}
      - Output: {"geojson": {...}, "total_km": 12.5, "sequence_ids": [0,1,5,10]}
      - Calls: backend.solve_tour()

3. Initialization Flow:
   - Server starts â†’ backend.load_data_initial() called
   - Graph and POIs loaded into memory (one-time operation)
   - Server ready to handle requests

--------------------------------------------------------------------------------

4.2 BACKEND.PY - Core Algorithm Implementation
----------------------------------------------
Location: /a_star/backend.py

This is the heart of the application, containing all custom algorithm 
implementations.

SECTION 1: CUSTOM ALGORITHMS
=============================

A) my_astar() - A* Pathfinding Algorithm
-----------------------------------------
Function Signature:
  def my_astar(G, source, target, heuristic, weight='length')

Purpose: Finds the shortest path between two nodes using A* algorithm

Parameters:
  - G: NetworkX graph (road network)
  - source: Starting node ID
  - target: Destination node ID
  - heuristic: Function to estimate remaining distance
  - weight: Edge attribute to use as cost (default: 'length')

Returns:
  - (total_distance, path_nodes) or (float('inf'), []) if no path found

Algorithm Steps:
  1. Initialize open set (priority queue) with source node
  2. Initialize g_score (actual cost from source) for all nodes to infinity
  3. Set g_score[source] = 0
  4. While open set is not empty:
     a. Pop node with lowest f_score (f = g + h)
     b. If node is target â†’ reconstruct and return path
     c. For each neighbor:
        - Calculate tentative g_score
        - If better than current g_score:
          * Update came_from pointer
          * Update g_score
          * Calculate f_score and add to open set
  5. If loop ends without finding target â†’ return failure

Key Features:
  - Uses heapq for efficient priority queue
  - Handles MultiDiGraph (multiple edges between same nodes)
  - Nested reconstruct_path() function to build final route

Example Usage:
  distance, path = my_astar(G, source=123, target=456, 
                            heuristic=heuristic_dist, weight='length')
  # Returns: (1520.5, [123, 124, 130, 456])

--------------------------------------------------------------------------------

B) heuristic_dist() - Haversine Distance Heuristic
--------------------------------------------------
Function Signature:
  def heuristic_dist(u, v, G)

Purpose: Calculates straight-line distance between two nodes using Haversine
         formula (great-circle distance on Earth's surface)

Parameters:
  - u: First node ID
  - v: Second node ID
  - G: Graph containing node coordinates

Returns:
  - Distance in meters (float)

Mathematical Formula:
  Given two points (lat1, lon1) and (lat2, lon2):
  
  Ï†1 = lat1 in radians
  Ï†2 = lat2 in radians
  Î”Ï† = (lat2 - lat1) in radians
  Î”Î» = (lon2 - lon1) in radians
  
  a = sinÂ²(Î”Ï†/2) + cos(Ï†1) Ã— cos(Ï†2) Ã— sinÂ²(Î”Î»/2)
  c = 2 Ã— atan2(âˆša, âˆš(1-a))
  d = R Ã— c
  
  Where R = 6,371,000 meters (Earth's radius)

Why Haversine?
  - Accounts for Earth's curvature
  - More accurate than Euclidean distance for geographic coordinates
  - Admissible heuristic (never overestimates actual distance)

Example:
  dist = heuristic_dist(node_123, node_456, G)
  # Returns: 1520.5 (meters)

--------------------------------------------------------------------------------

C) permutations() - Custom Permutation Generator
------------------------------------------------
Function Signature:
  def permutations(elements)

Purpose: Generates all possible orderings of elements (for TSP solving)

Parameters:
  - elements: List of items to permute

Returns:
  - List of all permutations (list of lists)

Algorithm (Recursive):
  1. Base case: If only 1 element, return [[element]]
  2. For each element at position i:
     a. Extract current element
     b. Get remaining elements (exclude i)
     c. Recursively get permutations of remaining
     d. Prepend current element to each permutation
  3. Combine all results

Example:
  permutations([1, 2, 3])
  # Returns: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]

Complexity:
  - Time: O(n! Ã— n)
  - Space: O(n!)
  - Practical limit: ~10 destinations

--------------------------------------------------------------------------------

SECTION 2: INTEGRATION FUNCTIONS
=================================

D) load_data_initial() - Data Loading
-------------------------------------
Function Signature:
  def load_data_initial()

Purpose: Loads geographic data from files into memory (called once at startup)

Process:
  1. Check for data files in 'data/' directory
  2. Load road network using OSMnx: ox.load_graphml()
  3. Load POIs using GeoPandas: gpd.read_file()
  4. Reset POI index for consistent ID mapping
  5. Print confirmation or error messages

Returns:
  - (G, pois): Tuple of (NetworkX graph, GeoDataFrame)
  - (None, None): If loading fails

File Paths:
  - Primary: data/balikpapan_jalan.graphml
  - Fallback: balikpapan_jalan.graphml (root directory)
  - Primary: data/balikpapan_pois.gpkg
  - Fallback: balikpapan_pois.gpkg

Error Handling:
  - Catches all exceptions
  - Prints detailed error messages
  - Returns None values to signal failure

--------------------------------------------------------------------------------

E) get_pois_for_frontend() - POI Data Formatter
-----------------------------------------------
Function Signature:
  def get_pois_for_frontend(pois_gdf)

Purpose: Converts GeoDataFrame to simple JSON-friendly format for UI

Parameters:
  - pois_gdf: GeoDataFrame containing POI data

Returns:
  - List of dictionaries: [{"id": int, "name": str, "lat": float, "lon": float}]

Process:
  1. Filter POIs with valid names (name is not null)
  2. For each POI:
     - Extract index as ID
     - Extract name from 'name' column
     - Extract latitude from geometry.y
     - Extract longitude from geometry.x
  3. Build list of dictionaries

Example Output:
  [
    {"id": 0, "name": "Alfamidi Ahmad Yani", "lat": -1.248, "lon": 116.86},
    {"id": 5, "name": "Pantai Lamaru", "lat": -1.234, "lon": 116.87}
  ]

--------------------------------------------------------------------------------

F) solve_tour() - Main Route Solving Function
---------------------------------------------
Function Signature:
  def solve_tour(G, pois, start_id, dest_ids)

Purpose: Calculates optimal multi-destination route (TSP with A*)

Parameters:
  - G: Road network graph
  - pois: GeoDataFrame of points of interest
  - start_id: Integer ID of starting location
  - dest_ids: List of integer IDs for destinations

Returns:
  Dictionary with:
    - "geojson": Route geometry for map visualization
    - "total_km": Total distance in kilometers
    - "sequence_ids": Ordered list of visited POI IDs
  OR
    - "error": Error message string

ALGORITHM WORKFLOW:
-------------------

Step 1: Extract Geometries
  - Get Point geometry for start POI
  - Get Point geometries for destination POIs
  - Combine into single list

Step 2: Snap to Road Network
  - Use ox.nearest_nodes() to find closest graph nodes
  - Input: Lists of longitudes and latitudes
  - Output: List of node IDs in graph
  - Purpose: POI coordinates may not exactly match road nodes

Step 3: Build Distance Matrix (Pairwise A*)
  - Create dictionary: distances[node_u][node_v] = distance
  - For each pair of nodes:
    * Call my_astar() to find shortest path
    * Store distance (or infinity if unreachable)
  - Complexity: O(nÂ² Ã— A*_complexity) where n = number of locations

Example Distance Matrix:
  distances = {
    node_123: {node_123: 0, node_456: 1500, node_789: 2000},
    node_456: {node_123: 1500, node_456: 0, node_789: 1800},
    node_789: {node_123: 2000, node_456: 1800, node_789: 0}
  }

Step 4: Solve TSP (Brute Force with Permutations)
  - Generate all permutations of destination nodes
  - For each permutation:
    * Start from start_node
    * Calculate total distance following the order
    * Track if path is valid (no infinite distances)
  - Keep track of shortest valid route
  - Store best order of destinations

TSP Pseudocode:
  best_distance = infinity
  best_order = []
  
  for each permutation P of destinations:
    current_distance = 0
    current_node = start_node
    valid = true
    
    for each next_node in P:
      edge_distance = distances[current_node][next_node]
      if edge_distance == infinity:
        valid = false
        break
      current_distance += edge_distance
      current_node = next_node
    
    if valid and current_distance < best_distance:
      best_distance = current_distance
      best_order = P

Step 5: Reconstruct Full Path for Visualization
  - Combine: [start_node] + best_order
  - For each consecutive pair:
    * Run A* again to get actual node sequence
    * Convert node sequence to edge list
  - Combine all edges into single route

Edge List Format:
  [(node1, node2, edge_key), (node2, node3, edge_key), ...]
  # edge_key is usually 0 for simplified graphs

Step 6: Generate GeoJSON Output
  - Create subgraph containing only route edges
  - Convert to GeoDataFrame using ox.graph_to_gdfs()
  - Ensure CRS is EPSG:4326 (lat/lon)
  - Convert to JSON format

Step 7: Return Result
  - Package GeoJSON, distance, and sequence
  - Handle any exceptions with error dictionary

Error Handling:
  - Disconnected graph â†’ "Rute terputus/tidak ditemukan"
  - Invalid POI IDs â†’ IndexError caught
  - General exceptions â†’ Traceback printed, error message returned

Performance Considerations:
  - Distance matrix: O(nÂ²) A* calls
  - TSP solving: O(n!) permutations
  - Practical limit: ~8-10 destinations
  - Total complexity: O(nÂ² Ã— A* + n!)

Example Call:
  result = solve_tour(G, pois, start_id=0, dest_ids=[1, 5, 10])
  # Returns:
  # {
  #   "geojson": {...},
  #   "total_km": 12.5,
  #   "sequence_ids": [0, 5, 1, 10]  # Optimized order
  # }

--------------------------------------------------------------------------------

G) main() - Manual Testing Function
-----------------------------------
Function Signature:
  def main()

Purpose: Allows testing the backend independently without Flask server

Process:
  1. Load data using load_data_initial()
  2. Define test locations by name
  3. Look up IDs from POI names
  4. Call solve_tour()
  5. Print results
  6. Save GeoJSON to file: manual_result.geojson

Usage:
  $ python a_star/backend.py

Example Test Data:
  - Start: "Alfamidi Ahmad Yani"
  - Destinations: ["Warung Tudai - Sumber Rejo", "Yova Mart Sumber Rejo", 
                   "Fajar Kost Balikpapan", "Pantai Lamaru"]

================================================================================
5. ALGORITHM IMPLEMENTATION DETAILS
================================================================================

5.1 A* Algorithm Deep Dive
---------------------------

The A* algorithm combines:
- Dijkstra's Algorithm (guarantees shortest path)
- Greedy Best-First Search (uses heuristic for speed)

Formula:
  f(n) = g(n) + h(n)
  
  Where:
  - f(n) = estimated total cost to reach goal through node n
  - g(n) = actual cost from start to node n
  - h(n) = heuristic estimate from node n to goal

Properties:
  - Complete: Always finds a path if one exists
  - Optimal: Finds shortest path if heuristic is admissible
  - Admissible heuristic: h(n) â‰¤ actual distance (never overestimates)

Our Implementation:
  - Heuristic: Haversine distance (always â‰¤ actual road distance)
  - Data structure: Min-heap (heapq) for efficient node selection
  - Handles MultiDiGraph by choosing minimum edge weight

Comparison with Dijkstra:
  - Dijkstra: Explores all directions equally (slower)
  - A*: Prioritizes nodes closer to goal (faster)
  - Performance gain: 30-70% fewer nodes explored (typical)

--------------------------------------------------------------------------------

5.2 TSP Solving Strategy
-------------------------

Problem: Given N destinations, find shortest route visiting all exactly once

Approaches Considered:
  1. Brute Force (Our Choice)
     - Pros: Guarantees optimal solution, simple implementation
     - Cons: O(n!) complexity
     - Practical for: n â‰¤ 10

  2. Greedy (Not Used)
     - Pros: Fast O(nÂ²)
     - Cons: Not optimal, can be 25% longer than optimal
  
  3. Dynamic Programming (Not Used)
     - Pros: Optimal, O(nÂ² Ã— 2â¿)
     - Cons: Complex implementation, still exponential

Our Implementation Choice Rationale:
  - Tourism use case: Typically 3-7 destinations
  - Acceptable computation time: < 5 seconds for 7 destinations
  - Code simplicity and maintainability
  - Guaranteed optimal solution (important for user experience)

Performance Benchmarks:
  - 3 destinations: ~instant (6 permutations)
  - 5 destinations: ~1 second (120 permutations)
  - 7 destinations: ~5 seconds (5,040 permutations)
  - 10 destinations: ~5 minutes (3,628,800 permutations)

--------------------------------------------------------------------------------

5.3 Graph Representation
-------------------------

Data Structure: NetworkX MultiDiGraph

Nodes:
  - ID: Unique integer (OSM node ID)
  - Attributes:
    * 'x': Longitude (float)
    * 'y': Latitude (float)
    * 'osmid': Original OpenStreetMap ID
    * 'street_count': Number of connected streets

Edges:
  - Structure: (u, v, key) tuple
  - Attributes:
    * 'length': Distance in meters (our primary weight)
    * 'osmid': OpenStreetMap way ID
    * 'name': Street name (if available)
    * 'highway': Road type (primary, secondary, residential, etc.)
    * 'oneway': Boolean for one-way streets
    * 'geometry': LineString for curved roads

MultiDiGraph Properties:
  - Multiple edges between same nodes allowed
  - Directed edges (important for one-way streets)
  - Example: Two parallel roads between intersections

Why MultiDiGraph?
  - Real roads can have multiple lanes/directions
  - One-way streets require directed edges
  - Roundabouts and complex intersections

Edge Weight Handling:
  if G.is_multigraph():
      cost = min(data.get('length', inf) for data in edge_data.values())
  else:
      cost = edge_data.get('length', inf)

This ensures we always use the shortest available path between nodes.

================================================================================
6. API ENDPOINTS
================================================================================

6.1 GET / (Homepage)
--------------------
URL: http://localhost:5000/
Method: GET
Purpose: Serves main application interface

Response: HTML page (templates/index.html)
Status Codes:
  - 200: Success

--------------------------------------------------------------------------------

6.2 GET /api/pois (POI Data)
----------------------------
URL: http://localhost:5000/api/pois
Method: GET
Purpose: Provides list of all points of interest for UI dropdowns

Request: None (no parameters)

Response Format (JSON):
[
  {
    "id": 0,
    "name": "Alfamidi Ahmad Yani",
    "lat": -1.2480,
    "lon": 116.8600
  },
  {
    "id": 1,
    "name": "Pantai Lamaru",
    "lat": -1.2340,
    "lon": 116.8700
  },
  ...
]

Response Fields:
  - id (int): Unique identifier (DataFrame index)
  - name (string): POI name (human-readable)
  - lat (float): Latitude coordinate
  - lon (float): Longitude coordinate

Status Codes:
  - 200: Success
  - 500: Server error (data loading failed)

Usage in Frontend:
  fetch('/api/pois')
    .then(res => res.json())
    .then(data => {
      // Populate dropdowns
      initApp(data);
    });

--------------------------------------------------------------------------------

6.3 POST /api/route (Route Calculation)
---------------------------------------
URL: http://localhost:5000/api/route
Method: POST
Purpose: Calculates optimal route based on user selections

Request Format (JSON):
{
  "start_id": 0,
  "dest_ids": [1, 5, 10]
}

Request Fields:
  - start_id (int): ID of starting location
  - dest_ids (array of int): List of destination IDs

Response Format (Success):
{
  "geojson": {
    "type": "FeatureCollection",
    "features": [
      {
        "type": "Feature",
        "geometry": {
          "type": "LineString",
          "coordinates": [[116.86, -1.248], [116.861, -1.249], ...]
        },
        "properties": {
          "length": 1500.5,
          "name": "Jalan Ahmad Yani",
          ...
        }
      },
      ...
    ]
  },
  "total_km": 12.5,
  "sequence_ids": [0, 5, 1, 10]
}

Response Fields:
  - geojson (object): Route geometry in GeoJSON format
  - total_km (float): Total route distance in kilometers
  - sequence_ids (array): Optimized order of POI visits

Response Format (Error):
{
  "error": "Rute terputus/tidak ditemukan."
}

Status Codes:
  - 200: Success (check for "error" key in response)
  - 400: Bad request (invalid JSON)
  - 500: Server error

Usage in Frontend:
  fetch('/api/route', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
      start_id: parseInt(startId),
      dest_ids: destIds.map(id => parseInt(id))
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.error) {
      alert("Error: " + data.error);
    } else {
      // Draw route on map
      displayRoute(data);
    }
  });

Processing Time:
  - Typical: 1-3 seconds
  - Depends on:
    * Number of destinations (exponential factor)
    * Graph complexity
    * Distance between points

================================================================================
7. FRONTEND IMPLEMENTATION
================================================================================

7.1 HTML Structure (templates/index.html)
------------------------------------------

Layout: Split-screen design
  - Left: Sidebar (350px wide, fixed)
  - Right: Map (remaining width, fills viewport)

Main Components:

A) Sidebar (#sidebar)
  - Title: "ğŸ—ºï¸ Rute Wisata A*"
  - Start Point Selector: TomSelect dropdown (single selection)
  - Destination Selector: TomSelect dropdown (multi-selection, max 10)
  - Search Button: "ğŸš€ Cari Rute Optimal"
  - Loading Indicator: Spinner during calculation
  - Result Card: Shows distance and route info

B) Map Container (#map)
  - Leaflet.js map instance
  - OpenStreetMap tiles
  - Marker clustering (MarkerCluster plugin)
  - Route polyline overlay

--------------------------------------------------------------------------------

7.2 JavaScript Architecture
----------------------------

Global Variables:
  - map: Leaflet map instance
  - routeLayer: Current route overlay (cleared on new search)
  - markers: Object storing all POI markers {id: markerObject}
  - tsStart: TomSelect instance for start point
  - tsDest: TomSelect instance for destinations
  - markersLayer: MarkerCluster group

Initialization Flow:
  1. Create Leaflet map centered on Balikpapan (-1.248, 116.86)
  2. Add OpenStreetMap tile layer
  3. Fetch POI data from /api/pois
  4. Initialize TomSelect dropdowns
  5. Create marker cluster group
  6. Add markers for each POI
  7. Set up event listeners

--------------------------------------------------------------------------------

7.3 Key Functions
-----------------

A) initApp(pois)
----------------
Purpose: Initialize application with POI data

Process:
  1. Format POI data for TomSelect: {value: id, text: name}
  2. Initialize TomSelect dropdowns with options
  3. Create MarkerCluster group
  4. Loop through POIs:
     - Create marker with grey icon
     - Bind tooltip with POI name
     - Add click handler for selection
     - Store marker reference
     - Add to cluster group
  5. Add cluster layer to map

Marker Click Behavior:
  - If no start selected: Set as start point (red marker)
  - If already a destination: Remove from destinations
  - Otherwise: Add to destinations (green marker)

--------------------------------------------------------------------------------

B) updateMarkers()
------------------
Purpose: Update marker colors based on selection state

Process:
  1. Get current start ID and destination IDs
  2. Loop through all markers:
     - If marker ID equals start ID: Set red icon, high z-index
     - If marker ID in destinations: Set green icon, medium z-index
     - Otherwise: Set grey icon, normal z-index

Color Coding:
  - Red: Starting point
  - Green: Selected destinations
  - Grey: Unselected POIs

Z-Index Layering:
  - Start (1000): Always on top
  - Destinations (900): Above unselected
  - Unselected (0): Default layer

--------------------------------------------------------------------------------

C) hitungRute() (Calculate Route)
----------------------------------
Purpose: Request route calculation and display results

Process:
  1. Validation: Check that start and at least 1 destination selected
  2. Show loading indicator
  3. Hide previous results
  4. Clear existing route from map
  5. Send POST request to /api/route
  6. On success:
     - Hide loading indicator
     - Check for errors
     - Create GeoJSON layer from response
     - Style route (blue, thick line)
     - Add to map
     - Fit map bounds to route
     - Display result card with distance
  7. On failure:
     - Hide loading indicator
     - Show error alert

Route Styling:
  {
    color: '#3498db',    // Blue
    weight: 6,           // Thick line
    opacity: 0.8         // Slightly transparent
  }

================================================================================
8. DATA FLOW
================================================================================

8.1 Application Startup
------------------------

Step 1: Server Initialization
  User runs: $ python app.py
  â†“
  Flask starts
  â†“
  backend.load_data_initial() called
  â†“
  Load balikpapan_jalan.graphml â†’ G_global
  â†“
  Load balikpapan_pois.gpkg â†’ pois_global
  â†“
  Server ready on http://localhost:5000

Step 2: User Opens Browser
  Browser requests: GET /
  â†“
  Flask serves: templates/index.html
  â†“
  Browser loads JavaScript
  â†“
  JavaScript requests: GET /api/pois
  â†“
  Flask returns POI list (JSON)
  â†“
  UI initialized with dropdowns and map markers

--------------------------------------------------------------------------------

8.2 Route Calculation Flow
---------------------------

User Interaction:
  1. User selects start point (click marker or dropdown)
     â†“
     Marker turns red, tsStart.setValue() called
     â†“
     updateMarkers() refreshes display

  2. User selects destinations (click markers or dropdown)
     â†“
     Markers turn green, tsDest.addItem() called
     â†“
     updateMarkers() refreshes display

  3. User clicks "ğŸš€ Cari Rute Optimal"
     â†“
     hitungRute() function triggered

Backend Processing:
  hitungRute() sends:
  {
    "start_id": 0,
    "dest_ids": [1, 5, 10]
  }
  â†“
  Flask receives POST /api/route
  â†“
  Calls: backend.solve_tour(G_global, pois_global, 0, [1, 5, 10])
  â†“
  
  solve_tour() executes:
    1. Extract POI geometries
    2. Snap to graph nodes using ox.nearest_nodes()
    3. Build distance matrix (A* for each pair)
       â”œâ”€ my_astar(G, node_0, node_1, heuristic_dist)
       â”œâ”€ my_astar(G, node_0, node_5, heuristic_dist)
       â”œâ”€ my_astar(G, node_0, node_10, heuristic_dist)
       â”œâ”€ my_astar(G, node_1, node_5, heuristic_dist)
       â””â”€ ... (all pairs)
    4. Solve TSP with permutations()
       â”œâ”€ Try [1, 5, 10]: total = 10km
       â”œâ”€ Try [1, 10, 5]: total = 12km
       â”œâ”€ Try [5, 1, 10]: total = 11km
       â”œâ”€ Try [5, 10, 1]: total = 13km
       â”œâ”€ Try [10, 1, 5]: total = 14km
       â””â”€ Try [10, 5, 1]: total = 15km
       â†’ Best: [1, 5, 10] with 10km
    5. Reconstruct full path with A*
       â”œâ”€ my_astar(0, 1) â†’ [0, 45, 46, 1]
       â”œâ”€ my_astar(1, 5) â†’ [1, 50, 51, 52, 5]
       â””â”€ my_astar(5, 10) â†’ [5, 60, 61, 10]
       â†’ Full path: [0, 45, 46, 1, 50, 51, 52, 5, 60, 61, 10]
    6. Convert to GeoJSON
    7. Return result
  
  â†“
  Flask returns:
  {
    "geojson": {...},
    "total_km": 10.0,
    "sequence_ids": [0, 1, 5, 10]
  }

Frontend Rendering:
  â†“
  JavaScript receives response
  â†“
  Create Leaflet GeoJSON layer
  â†“
  Add blue polyline to map
  â†“
  Fit map bounds to show entire route
  â†“
  Display "Total Jarak: 10.0 KM"

================================================================================
9. SETUP & INSTALLATION
================================================================================

9.1 Prerequisites
-----------------

Required Software:
  - Python 3.8 or higher
  - pip (Python package manager)
  - Modern web browser (Chrome, Firefox, Edge)

Required Python Packages:
  - flask
  - flask-cors
  - osmnx
  - geopandas
  - networkx
  - shapely
  - pyproj

--------------------------------------------------------------------------------

9.2 Installation Steps
-----------------------

Step 1: Clone/Download Project
  $ cd /path/to/your/workspace
  $ # Extract or clone project files

Step 2: Create Virtual Environment (Recommended)
  $ python -m venv venv
  $ source venv/bin/activate  # On Windows: venv\Scripts\activate

Step 3: Install Dependencies
  $ pip install flask flask-cors osmnx geopandas networkx

Step 4: Verify Data Files
  Ensure these files exist:
  - data/balikpapan_jalan.graphml
  - data/balikpapan_pois.gpkg

Step 5: Run Application
  $ python app.py

Step 6: Open Browser
  Navigate to: http://localhost:5000

Expected Output:
  ğŸš€ Menyalakan Server Flask...
  ğŸ”„ [Backend] Memuat data graph & POI...
  âœ… [Backend] Data berhasil dimuat.
   * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
   * Restarting with stat
   * Debugger is active!

--------------------------------------------------------------------------------

9.3 Testing Backend Independently
----------------------------------

To test algorithms without starting the web server:

  $ python a_star/backend.py

This will:
  1. Load graph and POI data
  2. Run test route calculation
  3. Print results to console
  4. Save GeoJSON to manual_result.geojson

You can then view the result in QGIS or any GeoJSON viewer.

================================================================================
10. USAGE GUIDE
================================================================================

10.1 Basic Usage
----------------

Step 1: Select Starting Point
  - Method A: Click on a grey marker on the map
  - Method B: Use the "Titik Awal" dropdown search
  â†’ Marker turns red

Step 2: Select Destinations (up to 10)
  - Method A: Click additional grey markers on the map
  - Method B: Use the "Destinasi" dropdown (multi-select)
  â†’ Markers turn green

Step 3: Calculate Route
  - Click "ğŸš€ Cari Rute Optimal" button
  - Wait for calculation (loading spinner shows)
  - Route appears as blue line on map
  - Distance shown in result card

Step 4: View Results
  - Blue line: Optimal route
  - Result card: Total distance in KM
  - Map automatically zooms to fit route

--------------------------------------------------------------------------------

10.2 Advanced Features
----------------------

A) Marker Clustering
  - At low zoom levels: Markers cluster together (shows number)
  - At high zoom levels: Individual markers visible
  - Click cluster: Zooms in to expand
  - Threshold: Zoom level 16 (fully expanded)

B) Changing Selections
  - Remove destination: Click green marker again (or use dropdown)
  - Change start point: Select new location in dropdown
  - Clear all: Refresh page

C) Map Interaction
  - Pan: Click and drag
  - Zoom: Mouse wheel or +/- buttons
  - Marker tooltips: Hover over marker to see name

--------------------------------------------------------------------------------

10.3 Limitations
----------------

1. Number of Destinations
   - Maximum: 10 destinations
   - Recommended: 3-7 for fast computation
   - Reason: TSP is O(n!), too slow beyond 10

2. Connectivity
   - All locations must be reachable by road
   - Islands or disconnected areas will return error
   - Error message: "Rute terputus/tidak ditemukan"

3. Calculation Time
   - 1-3 destinations: < 1 second
   - 4-6 destinations: 1-3 seconds
   - 7-10 destinations: 3-10 seconds
   - Dependent on CPU speed and graph size

4. Geographic Scope
   - Currently limited to Balikpapan city
   - To use other cities: Replace .graphml and .gpkg files

================================================================================
11. TECHNICAL DETAILS
================================================================================

11.1 Performance Optimizations
-------------------------------

1. Data Preloading
   - Graph and POIs loaded once at startup
   - Stored in global variables (G_global, pois_global)
   - Subsequent requests reuse cached data
   - Benefit: ~5-10 second saving per request

2. Marker Clustering
   - Uses Leaflet.markercluster plugin
   - Reduces DOM elements at low zoom
   - Improves rendering performance with 1000+ POIs
   - Configurable clustering threshold

3. Efficient Pathfinding
   - A* with admissible heuristic
   - Priority queue (heapq) for O(log n) operations
   - Early termination when goal found
   - Typical speedup: 30-70% vs Dijkstra

4. Distance Matrix Caching
   - Within solve_tour(), distances stored in dictionary
   - Avoids redundant A* calls
   - Symmetric distances not recalculated

--------------------------------------------------------------------------------

11.2 Security Considerations
-----------------------------

1. Input Validation
   Current state: Minimal validation
   - Frontend validates: start and destinations selected
   - Backend assumes: valid integer IDs within POI range
   
   Potential vulnerabilities:
   - No sanitization of POI IDs
   - No rate limiting on /api/route
   - No authentication/authorization
   
   Recommendations for production:
   - Validate ID ranges (0 â‰¤ id < len(pois))
   - Implement rate limiting (e.g., 10 requests/minute)
   - Add CSRF protection
   - Sanitize all user inputs

2. CORS Configuration
   Current: CORS(app) allows all origins
   
   For production:
   CORS(app, resources={
     r"/api/*": {
       "origins": ["https://yourdomain.com"]
     }
   })

3. Debug Mode
   Current: app.run(debug=True)
   
   For production:
   app.run(debug=False, host='0.0.0.0')

--------------------------------------------------------------------------------

11.3 Error Handling
-------------------

Backend Errors:

1. Data Loading Failure
   Trigger: Missing or corrupt .graphml/.gpkg files
   Response: Server exits with error message
   Recovery: Check file paths in load_data_initial()

2. Disconnected Graph
   Trigger: No path exists between nodes
   Response: {"error": "Rute terputus/tidak ditemukan"}
   Frontend: Shows alert dialog

3. Invalid POI IDs
   Trigger: ID outside valid range
   Response: IndexError (caught, returns error)
   Frontend: Shows alert dialog

Frontend Errors:

1. Network Failure
   Trigger: Server down or network issue
   Response: Catch block in fetch()
   Message: "Gagal menghubungi server"

2. Invalid Selections
   Trigger: No start or no destinations
   Response: Alert before sending request
   Message: "Pilih minimal 1 titik awal dan 1 destinasi!"

Logging:

Console Output:
  - Backend: Print statements for major operations
  - Frontend: console.log() for debugging
  
Production Recommendation:
  - Replace print() with proper logging (logging module)
  - Log to file with rotation
  - Different log levels (DEBUG, INFO, WARNING, ERROR)

================================================================================
12. FUTURE IMPROVEMENTS
================================================================================

12.1 Algorithm Enhancements
----------------------------

1. Dynamic Programming TSP
   Current: Brute force O(n!)
   Proposed: Held-Karp algorithm O(nÂ² Ã— 2â¿)
   Benefit: Handle 15-20 destinations
   Implementation: 2D DP table with bitmask states

2. Heuristic Improvements
   Current: Straight-line Haversine
   Proposed: Landmark-based heuristics
   Benefit: More accurate estimates â†’ faster A*
   Method: Precompute distances to strategic landmarks

3. Bidirectional A*
   Current: Single direction (source â†’ target)
   Proposed: Simultaneous search from both ends
   Benefit: ~50% reduction in nodes explored
   Complexity: Moderate implementation effort

4. Parallel Route Calculation
   Current: Sequential distance matrix computation
   Proposed: ThreadPoolExecutor for parallel A* calls
   Benefit: 2-4x speedup on multi-core systems
   Code example:
     from concurrent.futures import ThreadPoolExecutor
     with ThreadPoolExecutor() as executor:
         futures = [executor.submit(my_astar, G, u, v, heuristic_dist) 
                    for u, v in pairs]
         results = [f.result() for f in futures]

--------------------------------------------------------------------------------

12.2 Feature Additions
----------------------

1. Route Alternatives
   - Show top 3 routes with different trade-offs
   - Fastest vs shortest vs scenic
   - UI: Tabs or dropdown to switch between routes

2. Time Estimation
   - Add speed limits to graph edges
   - Calculate estimated travel time
   - Account for traffic patterns (time of day)

3. Waypoint Constraints
   - Allow user to specify "must visit before X"
   - Implement constrained TSP solver
   - UI: Drag-and-drop ordering

4. Export Functionality
   - Download route as GPX (for GPS devices)
   - Download as PDF with turn-by-turn directions
   - Share link to save/load routes

5. Multi-Modal Transportation
   - Combine walking, driving, public transit
   - Different graphs for different modes
   - Mode switching at specific locations

6. Real-Time Traffic
   - Integrate traffic data API
   - Adjust edge weights dynamically
   - Recalculate route if conditions change

7. Points of Interest Details
   - Show photos, ratings, descriptions
   - Operating hours
   - Estimated visit duration
   - Integration with Google Places API

--------------------------------------------------------------------------------

12.3 UI/UX Improvements
-----------------------

1. Mobile Responsiveness
   Current: Desktop-optimized
   Proposed: Responsive layout with media queries
   Features:
     - Collapsible sidebar
     - Touch-friendly controls
     - Swipe gestures

2. Route Visualization Enhancements
   - Animated route drawing
   - Turn-by-turn markers
   - Distance labels on segments
   - Elevation profile

3. Better Loading States
   - Progress bar for calculation steps
   - Estimated time remaining
   - Cancel button for long calculations

4. Accessibility
   - Keyboard navigation
   - Screen reader support (ARIA labels)
   - High contrast mode
   - Adjustable font sizes

5. Internationalization
   - Multi-language support
   - Localized distance units (km/miles)
   - Currency conversion for costs

--------------------------------------------------------------------------------

12.4 Technical Infrastructure
------------------------------

1. Database Integration
   Current: In-memory data
   Proposed: PostgreSQL with PostGIS
   Benefits:
     - Persistent route history
     - User accounts and saved routes
     - Analytics and usage tracking

2. Caching Layer
   - Redis for frequently requested routes
   - Cache distance matrices for common POIs
   - Invalidation strategy for graph updates

3. API Documentation
   - Swagger/OpenAPI specification
   - Interactive API explorer
   - Code examples for integration

4. Testing Suite
   - Unit tests for algorithms
   - Integration tests for API
   - Frontend end-to-end tests (Selenium/Cypress)
   - Performance benchmarks

5. Deployment
   - Containerization (Docker)
   - CI/CD pipeline
   - Production server (Gunicorn/uWSGI)
   - HTTPS with Let's Encrypt
   - Load balancing for scale

6. Monitoring
   - Application performance monitoring (APM)
   - Error tracking (Sentry)
   - Usage analytics
   - Health check endpoints

================================================================================
APPENDIX A: FILE FORMATS
================================================================================

A.1 GraphML Format (.graphml)
------------------------------
Purpose: Stores road network topology and attributes
Specification: XML-based graph format

Structure:
<?xml version="1.0" encoding="UTF-8"?>
<graphml>
  <key id="x" for="node" attr.name="x" attr.type="double"/>
  <key id="y" for="node" attr.name="y" attr.type="double"/>
  <key id="length" for="edge" attr.name="length" attr.type="double"/>
  
  <graph edgedefault="directed">
    <node id="123">
      <data key="x">116.8600</data>
      <data key="y">-1.2480</data>
    </node>
    
    <edge source="123" target="124">
      <data key="length">150.5</data>
      <data key="name">Jalan Ahmad Yani</data>
    </edge>
  </graph>
</graphml>

Loading in Python:
  import osmnx as ox
  G = ox.load_graphml('balikpapan_jalan.graphml')


--------------------------------------------------------------------------------

A.2 GeoPackage Format (.gpkg)
------------------------------
Purpose: Stores POI locations and attributes
Specification: SQLite-based geospatial format

Structure: (Conceptual - binary format)
Table: points_of_interest
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ fid â”‚ name                 â”‚ type    â”‚ geometry â”‚ ...      â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0   â”‚ Alfamidi Ahmad Yani â”‚ shop    â”‚ POINT()  â”‚ ...      â”‚
â”‚ 1   â”‚ Pantai Lamaru       â”‚ tourism â”‚ POINT()  â”‚ ...      â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Loading in Python:
  import geopandas as gpd
  pois = gpd.read_file('balikpapan_pois.gpkg')
  
Accessing data:
  pois.iloc[0]['name']        # 'Alfamidi Ahmad Yani'
  pois.iloc[0].geometry.x     # 116.8600
  pois.iloc[0].geometry.y     # -1.2480

--------------------------------------------------------------------------------

A.3 GeoJSON Format (.geojson)
------------------------------
Purpose: Route output for map visualization
Specification: JSON-based geospatial format

Example:
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "geometry": {
        "type": "LineString",
        "coordinates": [
          [116.8600, -1.2480],
          [116.8601, -1.2481],
          [116.8602, -1.2482]
        ]
      },
      "properties": {
        "length": 150.5,
        "name": "Jalan Ahmad Yani",
        "highway": "primary"
      }
    }
  ]
}

Rendering in Leaflet:
  L.geoJSON(geojson, {
    style: {color: '#3498db', weight: 6}
  }).addTo(map);

================================================================================
APPENDIX B: DEPENDENCY REFERENCE
================================================================================

B.1 Python Packages
--------------------

osmnx (v1.x)
  Purpose: Loading and processing OpenStreetMap data
  Key functions:
    - ox.load_graphml(): Load graph from file
    - ox.nearest_nodes(): Snap coordinates to graph
    - ox.graph_to_gdfs(): Convert graph to GeoDataFrame
  Documentation: https://osmnx.readthedocs.io/

geopandas (v0.x)
  Purpose: Geographic data manipulation
  Key functions:
    - gpd.read_file(): Load geospatial files
    - gdf.to_crs(): Coordinate system transformation
    - gdf.to_json(): Export to GeoJSON
  Documentation: https://geopandas.org/

networkx (v2.x/3.x)
  Purpose: Graph data structure and algorithms
  Key classes:
    - MultiDiGraph: Directed multigraph
  Documentation: https://networkx.org/

flask (v2.x/3.x)
  Purpose: Web framework
  Key decorators:
    - @app.route(): Define URL routes
    - @app.before_first_request: Startup tasks
  Documentation: https://flask.palletsprojects.com/

flask-cors (v3.x)
  Purpose: Cross-Origin Resource Sharing
  Usage: CORS(app)
  Documentation: https://flask-cors.readthedocs.io/

--------------------------------------------------------------------------------

B.2 JavaScript Libraries
-------------------------

Leaflet.js (v1.9.4)
  Purpose: Interactive map rendering
  Core objects:
    - L.map(): Create map instance
    - L.tileLayer(): Add base map tiles
    - L.marker(): Add point markers
    - L.geoJSON(): Render GeoJSON data
  Documentation: https://leafletjs.com/

Leaflet.markercluster (v1.4.1)
  Purpose: Cluster nearby markers
  Usage:
    var cluster = L.markerClusterGroup();
    cluster.addLayer(marker);
    map.addLayer(cluster);
  Documentation: https://github.com/Leaflet/Leaflet.markercluster

TomSelect (v2.2.2)
  Purpose: Advanced dropdown with search
  Features:
    - Multi-select support
    - Live search
    - Programmatic control
  Documentation: https://tom-select.js.org/

================================================================================
APPENDIX C: MATHEMATICAL FORMULAS
================================================================================

C.1 Haversine Distance
-----------------------

Given two points P1(lat1, lon1) and P2(lat2, lon2):

Step 1: Convert to radians
  Ï†1 = lat1 Ã— Ï€/180
  Ï†2 = lat2 Ã— Ï€/180
  Î”Ï† = (lat2 - lat1) Ã— Ï€/180
  Î”Î» = (lon2 - lon1) Ã— Ï€/180

Step 2: Calculate intermediate value
  a = sinÂ²(Î”Ï†/2) + cos(Ï†1) Ã— cos(Ï†2) Ã— sinÂ²(Î”Î»/2)

Step 3: Calculate angular distance
  c = 2 Ã— atan2(âˆša, âˆš(1-a))

Step 4: Calculate distance
  d = R Ã— c
  
  where R = 6,371,000 meters (mean Earth radius)

Example Calculation:
  P1 = (-1.2480Â°, 116.8600Â°)
  P2 = (-1.2340Â°, 116.8700Â°)
  
  Ï†1 = -0.021778 rad
  Ï†2 = -0.021534 rad
  Î”Ï† = 0.000244 rad
  Î”Î» = 0.000175 rad
  
  a = 0.0000000149
  c = 0.0000000745
  d â‰ˆ 1,562 meters

--------------------------------------------------------------------------------

C.2 A* f-score Formula
----------------------

For node n:
  f(n) = g(n) + h(n)

Where:
  g(n) = Actual cost from start to n
  h(n) = Estimated cost from n to goal (heuristic)
  f(n) = Estimated total cost of path through n

Properties:
  - If h(n) = 0: Becomes Dijkstra's algorithm
  - If h(n) â‰¤ actual_distance(n, goal): Admissible (guarantees optimal)
  - If h(n) = actual_distance(n, goal): Optimal performance

Our implementation:
  g(n) = Sum of edge lengths from start to n
  h(n) = Haversine distance from n to goal
  
  Since road distance â‰¥ straight-line distance, h(n) is admissible.

================================================================================
APPENDIX D: TROUBLESHOOTING
================================================================================

D.1 Common Issues
-----------------

Issue 1: "ModuleNotFoundError: No module named 'osmnx'"
Solution:
  $ pip install osmnx geopandas

Issue 2: "FileNotFoundError: balikpapan_jalan.graphml"
Solution:
  - Check data/ directory exists
  - Verify file names match exactly
  - Check file paths in load_data_initial()

Issue 3: Map doesn't load / blank screen
Solution:
  - Check browser console for errors (F12)
  - Verify internet connection (for map tiles)
  - Check static files are accessible

Issue 4: Route calculation takes very long
Solution:
  - Reduce number of destinations (try 3-5)
  - Check graph size (large graphs slower)
  - Consider implementing timeout

Issue 5: "Rute terputus/tidak ditemukan"
Solution:
  - Selected points may be on disconnected road networks
  - Try different POI combinations
  - Check graph connectivity

Issue 6: Markers don't appear
Solution:
  - Check /api/pois returns data
  - Verify POI coordinates are valid
  - Check MarkerCluster library loaded

--------------------------------------------------------------------------------

D.2 Debugging Tips
------------------

Backend Debugging:
  1. Run backend independently:
     $ python a_star/backend.py
  
  2. Add print statements:
     print(f"Distance from {u} to {v}: {distance}")
  
  3. Check data loading:
     print(f"Graph has {len(G.nodes)} nodes")
     print(f"POIs: {len(pois)} locations")

Frontend Debugging:
  1. Open browser console (F12)
  
  2. Check network requests:
     - Look for /api/pois and /api/route calls
     - Verify response status codes
  
  3. Inspect variables:
     console.log('Start ID:', tsStart.getValue());
     console.log('Dest IDs:', tsDest.getValue());

Performance Profiling:
  import time
  start = time.time()
  result = solve_tour(...)
  print(f"Calculation took {time.time() - start:.2f} seconds")

================================================================================
APPENDIX E: REFERENCES & RESOURCES
================================================================================

E.1 Academic Papers
-------------------

1. A* Algorithm
   Hart, P. E.; Nilsson, N. J.; Raphael, B. (1968). 
   "A Formal Basis for the Heuristic Determination of Minimum Cost Paths". 
   IEEE Transactions on Systems Science and Cybernetics.

2. Traveling Salesman Problem
   Applegate, D. L.; Bixby, R. E.; ChvÃ¡tal, V.; Cook, W. J. (2006).
   "The Traveling Salesman Problem: A Computational Study".
   Princeton University Press.

--------------------------------------------------------------------------------

E.2 Online Resources
--------------------

OpenStreetMap:
  https://www.openstreetmap.org/
  
OSMnx Documentation:
  https://osmnx.readthedocs.io/
  
Leaflet.js Tutorials:
  https://leafletjs.com/examples.html
  
Graph Algorithms Visualization:
  https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

================================================================================
END OF DOCUMENTATION
================================================================================

For questions or support:
- Check the code comments in individual files
- Review error messages in console/terminal
- Consult library documentation for specific functions

Last Updated: 2024
Version: 1.0
